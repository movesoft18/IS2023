#include <iostream>
using namespace std;

#include <iostream>
using namespace std;


//#define debug

struct StackItem // собственно сам элемент стека
{
    char symbol; // точка
    StackItem* next;  // указатель на следующий элемент в списке
};

StackItem* stack = nullptr; // указатель на вершину стека, изначально стек пуст

bool IsEmpty() // функция проверяет пуст ли стек
{
    return stack == nullptr;
}

void Push(char symbol) // Добавление точки в стек (аналог функции AddFirst линейного списка)
{
    StackItem* item = new StackItem{ symbol, stack }; // этой строчкой можно заменить следующие 2
    stack = item; // теперь вершина стека указывает на добавленный элемент
}

char Pop() // извлекает элемент из стека и возвращает его значение
{
    char result; // здесь будет результат
    StackItem* temp; // временная переменная
    if (stack == nullptr) // если стек пуст
    {
        result = 0;
        return result;  // поэтому пока возвращаем Point {0,0}
    }
    result = stack->symbol; //записываем возвращаемые данные
    temp = stack;   // запоминаем элемент на вершине стека
    stack = temp->next; // перемещаем вершину стека на следующий за извлекаемым элемент
    delete temp;    // освобождаем память, занятую элементом на вершине
    return result; // возвращаем результат
}
// функция проверяет правильность расстановки скобок () и [] в выражении str
// возвращает true, если в выражении скобки расставлены корректно и false в противном случае
bool IsCorrectString(const string& str)
{
    for (int i = 0; i < str.length(); i++) //посимвольно пробегаем по всей строке
    {
        char e = str[i]; // помещаем в е очередной символ из строки
        switch (e) // и проверяем его
        {
        case '[': //если это открывающая скобка
#ifdef debug
            cout << "Встретилась скобка [\n";
#endif
        case '(':
#ifdef debug
            if (e == '(')
                cout << "Встретилась скобка (\n";
#endif
        //case '{':
            Push(e); // то помещаем ее символ в стек
            break;
        case ']': // если это открывающая квадратная скобка
#ifdef debug
            cout << "Встретилась скобка ]\n";
#endif
            if (IsEmpty()) // проверяем пуст ли стек, и если стек пуст, значит данная скобка лишняя
                return false; // ей не соответствует ни одна открывающая, возвращаем false
            if (Pop() != '[')  // если в стеке есть символы, извлекаем его и сравниваем с открывающей скобкой
            {
                while (!IsEmpty()) Pop(); // чистим стек перед окончанием (если он не пустой)
                return false; // если символ другой, то нарушен порядок следования круглых и квадратных скобок
            }
            break;
        case ')':    // те же действия. что и выше, но уже с круглыми скобками
#ifdef debug
            cout << "Встретилась скобка )\n";
#endif
            if (IsEmpty())
                return false;
            if (Pop() != '(')
            {
                while (!IsEmpty()) Pop(); // чистим стек перед окончанием (если он не пустой)
                return false;
            }
            break;
        }
    }
    bool result = IsEmpty(); // если строка закончилась, а стек не пуст, значить открывающих скобок больше, ошибка
    while (!IsEmpty()) Pop(); // чистим стек перед окончанием (если он не пустой)
    return result;
}

int main()
{
    setlocale(LC_ALL, "");
    cout << IsCorrectString("2*(6x+1)-[(4-6)*(3+x)]^2 -(((3-z)-z)*x)") << endl; // правильное выражение
    cout << IsCorrectString("2*(6x+1))-[(4-6)*(3+x)]^2 -(((3-z)-z)*x)") << endl; // неправильное лишняя ) скобка
    cout << IsCorrectString("2*(6x+1)-[(4-6)*(3+x)]^2 -(((3-z)-z)*x]") << endl; // неправильное нарушен порядок скобок, последняя должна быть ), а по факту ]
    cout << IsCorrectString("2*(6x+1)-[(4-6)*(3+x)]^2 -[((3-z)-z)*x)") << endl;  //неправильное нарушен порядок скобок, последняя должна быть ], а по факту )
    cin.get();
}