
#include <iostream>
#include <map>
#include <string>
#include <vector>
using namespace std;

map <string, string> tel;


void printmap()
{
    /*for (auto i = tel.begin(); i != tel.end(); i++) // перебор всех итераторов словаря. Для каждого итератора
    {
        cout << "Абонент:" << i->first << "\tТелефон: " << i->second << endl;  // вывод значения, на которое он указывает
    }         */                                                             // при том i->first ключ
                                                                           // i->second значение
    // альтернативняа форма оператора for
    for (auto i : tel)
    {
        cout << "Абонент:" << i.first << "\tТелефон: " << i.second << endl; // но в таком виде итератор не указатель на 
                                                                        // элемент словаря а сам элемент словаря
    }                                                                   // разыменование не нужно
}

int main()
{
    system("chcp 1251");
    //vector<string> names{"Петров","Иванов","Сидоров"};
    tel = { {"Иванов", "89128543212"},  // инициализируем начальными значениями с++ v11 и выше
            {"Петров", "89128543213"},
            {"Сидоров", "89128543214"},
            {"Бабушкин", "89128543215"}
    };

    tel["Степанов"] = "3-21-57";  // или можно вот так добавлять элемент, ключ в скобках, 
                                  // значение справа от оператора присваивания
    tel["Бабушкин"] = "2-22-22";

    string s5 = tel["Иванов"];

    tel.insert(pair<string, string>("Служба спасения", "112")); // еще один способ добавления с помощью шаблона
                                                                // pair, описывающего структуру из 2-х элементов
                                                                // pair - по англ. "пара"

    tel.insert(pair<string, string>("Служба спасения", "911")); //при попытке вставить значение с ключом, который
                                                                  // уже существует - такая вставка игнорируется

    tel.insert(make_pair("Автосервис 555", "8(3412)77-88-99")); //  еще один способ добавления с помощью метода
                                                                // генерации пары make_pair()
    tel.insert({ "1","2" });
    auto g = tel.erase("Служба спасения");  // удаление элемента по ключу
    cout << g << endl;                      // g=1 если успех
    g = tel.erase("111");
    if (!g) cout << "Ключ не найден " << endl; // g=0 если ключ не существует
    printmap();

    cout << tel["Степанов"] << endl; // вот так тоже можно печатать значение по его ключу
    cout << tel.at("Петров") << endl; // или так, метод at возвращает значение элемента контейнера по его ключу

    try
    {
        cout << tel.at("Петро") << endl; // Печать несуществующего элемента, если такого ключа нет то возникнет исключение
    }
    catch (out_of_range e)
    {
        cout << "Ошибка, " << e.what() << endl;
    }

    if (tel.count("Петро") > 0)
        cout << tel["Петро"] << endl; // Печать несуществующего элемента, если ключ задавать в [], то никаких исключений не генерируется

    // Поиск в словаре (ассоциативный контейнер map, хранящий пары  <ключ, значение> называют словарем)
    auto pos = tel.find("Автосервис 555"); // метод find возврящает итератор на найденный элемент
    if (pos != tel.end())             // или 0 в противном случае. Это также соответствует значению tel.end()
        cout << pos->second << endl;
    else
        cout << "Ключ не найден" << endl;

    pos = tel.find("Иванов");
    if (pos != tel.end())
        tel.erase(pos, tel.end()); // стираем все элементы с "Иванов" и до конца.

    cout << "Размер словаря " << tel.size() << " элементов" << endl; // метод size вощврящает количество элементов словаря

    cout << "Количество элементов с заданным ключом " << tel.count("Автосервис 555") << " элементов" << endl; // будет 1
    cout << "Количество элементов с заданным ключом " << tel.count("Автосервиc 666") << " элементов" << endl; // будет 0

    tel.clear(); // удаляет все элементы словаря

// пример реализации телефонной книги с произвольным количеством телефонов для одного контакта
    map <string, vector<string>> multiTel; // в качестве значения в словаре - вектор строк (телефонов)

    vector<string> t = { "89123456777","89098756433","89634832206","4-22-55" }; // заполняем вектор телефонами

    multiTel.insert(pair<string, vector<string>>("Ивановский", t));

    t = { "8912444567","8906666663","8963488888" };
    multiTel["Петровский"] = t; //альтернативный способ  добавления контакта с телефонами
    t = { "8909555567","8963766663","89990488888" };
    multiTel.insert(make_pair("Сидоровский", t)); //еще один альтернативный способ  добавления контакта с телефонами

    // вывод контактов на экран
    cout << "\n\n\n";
    for (auto i : multiTel)
    {
        cout << "ФИО: " << i.first << "\t" << endl; // выводим ключ - фамилию контакта
        for (auto j : i.second) //i.second -это vector <string> в данном случае
        {
            cout << "\t" << j << endl; // выводим очередной номер контакта
        }

        /*  for (int j = 0; j < i.second.size(); j++) // это альтернативный способ вывода
          {
              cout << "\t" << i.second[j] << endl;
          }*/
    }
}

