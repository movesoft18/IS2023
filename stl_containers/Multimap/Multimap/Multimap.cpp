
#include <iostream>
#include <map>
#include <string>
#include <vector>
using namespace std;

multimap <string, string> tel;


void printmap()
{
    for (auto i = tel.begin(); i != tel.end(); i++) // перебор всех итераторов словаря. Для каждого итератора
    {
        cout << "ФИО:" << i->first << "\tТелефон: " << i->second << endl;  // вывод значения, на которое он указывает
    }                                                                      // при том i->first ключ
                                                                           // i->second значение
    // альтернативняа форма оператора for
    for (const auto& i : tel)
    {
        cout << "ФИО:" << i.first << "\tТелефон: " << i.second << endl; // но в таком виде итератор не указатель на 
        // элемент словаря а сам элемент словаря
    }                                                                   // разыменование не нужно
}

void printByKey(string key)
{
    auto r = tel.equal_range(key);  // ищем значения с ключом key
    // r - пара итераторов, соответствующая первому значению
    // элемента с ключом и последнего
    if (r.first != tel.end())
    {
        cout << "ФИО: " << r.first->first << endl;
        for (auto i = r.first; i != r.second; i++)
        {
            cout << "\t тел: " << i->second << endl;
        }
    }

}

int main()
{
    system("chcp 1251");
    tel = { {"Иванов", "89128543212"},  // инициализируем начальными значениями с++ v11 и выше
            {"Петров", "89128543213"},
            {"Петров", "89128543555"},

            {"Сидоров", "89128543214"},
            {"Бабушкин", "89128543215"},
            {"Бабушкин", "89121111111"}

    };

    //tel["Степанов"] = "3-21-57";  // В отличие от map такой способ добавления элемента не существует 

    tel.insert(pair<string, string>("Служба спасения", "112")); // еще один способ добавления с помощью шаблона
    // pair, описывающего структуру из 2-х элементов
    // pair - по англ. "пара"

    tel.insert(pair<string, string>("Служба спасения", "911")); //при попытке вставить значение с ключом, который
    // уже существует - вставляется еще один элемент с таким же ключом

    tel.insert({ "Бабушкин","6-66-66" }); // вот еще альтернативная вставка, которая работает и для map тоже

    tel.insert(make_pair("Автосервис 555", "8(3412)77-88-99")); //  еще один способ добавления с помощью метода
    // генерации пары make_pair()
    tel.insert({ "Автосервис 555" ,"2-22-22" });
    tel.insert({ "Автосервис 555" ,"2-33-33" });
    tel.insert({ { "Автосервис 555" ,"2-44-44" }, {"Галяутдинов","89990001122"} });


    auto g = tel.erase("Служба спасения");  // удаление элемента по ключу, удаляются все элементы с этим ключом
    cout << g << endl;                      // g=1 если успех
    g = tel.erase("111");
    if (!g) cout << "Ключ не найден " << endl; // g=0 если ключ не существует
    printmap();

    // cout << tel["Степанов"]<< endl; // Операция индексирования неприменима
    // cout << tel.at("Петров") << endl; // метод at() неприменим



     // Поиск в словаре (ассоциативный контейнер multimap, хранящий пары  <ключ, значение> называют словарем)
    auto pos = tel.find("Автосервис 555"); // метод find возврящает итератор на найденный элемент
    if (pos != tel.end())             // или 0 в противном случае. Это также соответствует значению tel.end()
        cout << pos->second << endl;
    else
        cout << "Ключ не найден" << endl;

    pos = tel.find("Иванов");
    if (pos != tel.end())
        tel.erase(pos, tel.end()); // стираем все элементы с "Иванов" и до конца.

    cout << "Размер словаря " << tel.size() << " элементов" << endl; // метод size вощврящает количество элементов словаря
    cout << "Количество элементов с заданным ключом " << tel.count("Автосервис 555") << " элементов" << endl; // будет 4
    cout << "Количество элементов с заданным ключом " << tel.count("Автосервиc 666") << " элементов" << endl; // будет 0
    printByKey("Автосервис 555");
    tel.clear(); // удаляет все элементы словаря


}

