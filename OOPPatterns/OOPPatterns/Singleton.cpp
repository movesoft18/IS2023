//Назначение паттерна Singleton
//Часто в системе могут существовать сущности только в единственном экземпляре, например, система ведения системного 
// журнала сообщений или драйвер дисплея.В таких случаях необходимо уметь создавать единственный экземпляр некоторого 
// типа, предоставлять к нему доступ извне и запрещать создание нескольких экземпляров того же типа.
//
//Паттерн Singleton предоставляет такие возможности.
//
//Описание паттерна Singleton
//Архитектура паттерна Singleton основана на идее использования глобальной переменной, имеющей следующие важные свойства
//  :
//
//Такая переменная доступна всегда.Время жизни глобальной переменной - от запуска программы до ее завершения.
//Предоставляет глобальный доступ, то есть, такая переменная может быть доступна из любой части программы.
//Однако, использовать глобальную переменную некоторого типа непосредственно невозможно, так как существует проблема 
// обеспечения единственности экземпляра, а именно, возможно создание нескольких переменных того же самого типа
// (например, стековых).
//
//Для решения этой проблемы паттерн Singleton возлагает контроль над созданием единственного объекта на сам класс.Доступ к
//этому объекту осуществляется через статическую функцию - член класса, которая возвращает указатель или ссылку на него.
//Этот объект будет создан только при первом обращении к методу, а все последующие вызовы просто возвращают его адрес.
//Для обеспечения уникальности объекта, конструкторы и оператор присваивания объявляются закрытыми.

#include <iostream>
#include <cassert>
using namespace std;

class Singleton
{
private:
    static Singleton* p_instance;
    // Конструкторы и оператор присваивания недоступны клиентам
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);
public:
    // ... Еще какие-то методы, реализующие функционал
    static Singleton* getInstance() {
        if (!p_instance)
            p_instance = new Singleton();
        return p_instance;
    }
};

Singleton* Singleton::p_instance = 0;

//Singleton Мэйерса
//Внутри getInstance() используется статический экземпляр нужного класса.Стандарт языка программирования C++ 
// гарантирует автоматическое уничтожение статических объектов при завершении программы.Досрочного уничтожения 
// и не требуется, так как объекты Singleton обычно являются долгоживущими объектами.Статическая функция - член 
// getInstance() возвращает не указатель, а ссылку на этот объект, тем самым, затрудняя возможность ошибочного 
// освобождения памяти клиентами.
class Singleton1
{
private:
    Singleton1() {}
    Singleton1(const Singleton1&);
    Singleton1& operator=(Singleton1&);
public:
    void DoWork()
    {
        cout << "Working!\n";
    }
    ~Singleton1()
    {
        cout << "Singleton destroyed";
    }
    static Singleton1& getInstance() {
        static Singleton1  instance;
        return instance;
    }
};



int main()
{
    Singleton* s_obj = nullptr;
    s_obj = Singleton::getInstance(); // Создаем singleton
    // ....
    // Если в другом блоке кода пытаемся еще раз создать синглтон, то его создания не происходит, просто возвращается
    // указатель на уже созданный объект
    Singleton* s_obj1 = Singleton::getInstance(); 
    // удаление по любому из указателей
    delete s_obj;

    Singleton1& s1_obj = Singleton1::getInstance();
    s1_obj.DoWork();
}

